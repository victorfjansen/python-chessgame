@startuml Checkers
skinparam groupInheritance 4
skinparam nodesep 50

package GameEntity <<Frame>> {
    class Game {}

    class GameModel {
        - _graphics: Graphics
        - _board: Board
        - _turn: COLORS
        - _selected_piece: Piece
        - _hop: boolean
        - _selected_legal_moves: List[List[]]
        - _mouse_pos: List[int]
        + get_graphics(): Graphics
        + set_graphics(graphics: Graphics): void
        + get_board(): Board
        + set_board(board: Board): void
        + get_turn(): COLORS
        + set_turn(turn: COLORS): void
        + get_selected_piece(): Piece
        + set_selected_piece(selected_piece: Piece): void
        + get_hop(): boolean
        + set_hop(hop: boolean): void
        + get_selected_legal_moves(): [][]
        + set_selected_legal_moves(selected_legal_moves: [][]): void
        + get_mouse_pos(): int[]
        + set_mouse_pos(mouse_pos: int[]): void
        + set_main_menu(main_menu: MainMenu): void
        + get_main_menu(): MainMenu
        + set_difficulty_level(value, level: number): void
        + get_difficulty_level(self): number
        + set_enemy_turn(enemy_turn): void
        + get_enemy_turn(): number
        + set_enemy(enemy: EnemyContract): void
        + get_enemy(): EnemyContract
        + set_end_game(end_game: boolean): void
        + get_end_game(): boolean
    }

    abstract class GameContract {
        + setup(): void
        + event_loop(): void
        + update(): void
        + terminate_game(): void
        + main(): void
        + end_turn(): void
        + check_for_endgame(): boolean
        + clean_board_store(): void
        + load_stored_game(): void
        + setup_enemy(): void
    }

    class MainMenu {}

    class MenuContract {
        + has_data_on_store(): boolean
        + setup_menu(game): void
    }

    class MenuModel {
        - __surface: Surface
        + get_surface(): Surface
        + set_surface(value: Surface): void
    }

}

package GraphicsEntity <<Frame>> {
    class GraphicsModel {
        - _text_font_obj: Font
        - _text_rect_obj: Rect
        - _text_surface_obj: Surface
        - _caption: string
        - _fps: int
        - _clock: Clock
        - _window_size: int
        - _screen: Surface
        - _scaledbackground: Surface
        - _square_size: int
        - _piece_size: int
        - _message: string
        
        + get_text_font_obj(): Font
        + set_text_font_obj(text_font_obj: Font): void
        + get_text_rect_obj(): Rect
        + set_text_rect_obj(text_rect_obj: Rect): void
        + get_text_surface_obj(): Surface
        + set_text_surface_obj(text_surface_obj: Surface): void
        + get_caption(): string
        + set_caption(caption: string): void
        + get_fps(): int
        + set_fps(fps: int): void
        + get_clock(): Clock
        + set_clock(clock: Clock): void
        + get_window_size(): int
        + set_window_size(window_size: int): void
        + get_screen(): Surface
        + set_screen(screen: Surface): void
        + get_scaledbackground(): Surface
        + set_scaledbackground(scaledbackground: Surface): void
        + get_square_size(): int
        + set_square_size(square_size: int): void
        + get_piece_size(): int
        + set_piece_size(piece_size: int): void
        + get_message(): string
        + set_message(message: string): void
    }

    abstract class GraphicsContract {
        + setup_window(): void
        + update_display(board: Board, legal_moves: List[List[]], selected_piece: Piece): void
        + draw_board_squares(board: Board): void
        + draw_board_pieces(board: Board): void
        + pixel_coords(board_coords: tuple[int]): tuple[int]
        + board_coords(pixel: tuple[int]): tuple[int]
        + highlight_squares(squares: List[], origin: tuple[int]): void
        + draw_message(message: string): void
    }

    class Graphics {}
}

package Core <<Rectangle>> {
    package PieceEntity {
    class PieceModel {
        - __color: COLORS
        - __king: boolean
        + get_color(): COLORS
        + set_color(color: COLORS): void
        + get_king(): boolean
        + set_king(king: boolean): void
    }

    class Piece{}
}

package SquareEntity <<Frame>>{
    class SquareModel {
        - __color: COLORS
        - __occupant: Piece
        + get_color(): COLORS
        + set_color(color: COLORS): void
        + get_occupant(): Piece
        + set_occupant(piece: Piece): void
    }

    class Square {}
}

package BoardEntity <<Frame>> {
    class BoardModel {
        - _matrix: List[List[None or int]]
        - __board_store: BoardStore
        + get_matrix(): List[List[None or int]]
        + set_matrix(matrix: List[List[None or int]]): void
        + get_board_store(): BoardStore
    }

    abstract class BoardContract {
        + new_board(): List[List[None or int]]
        + position(direction: Directions, pixel: tuple[int]): tuple[int]
        + adjacent(pixel: tuple[int]): List[tuple[int]]
        + location(pixel: tuple[int]): tuple[int]
        + blind_legal_moves(pixel: tuple[int]): List[tuple[int]]
        + legal_moves(pixel: tuple[int], hop: boolean): List[tuple[int]]
        + remove_piece(pixel: tuple[int]): void
        + move_piece(pixel_start: tuple[int], pixel_end: tuple[int]): void
        + is_end_square(coords: List[]): void
        + on_board(pixel: tuple[int]): void
        + verify_and_set_king(pixel: tuple[int]): void
        + get_direction_from_coors(current_pos: tuple[int], to_go_pos: tuple[int]): Directions
        + get_how_many_pieces_in_board(): dict
        + get_player_pieces_position(game: Game): List[tuple[int]]
    }

    class Board {}

    class BoardStore {
        + formatted_color(color: tuple[int, int, int]): str
        + store_matrix(matrix: List[List[int]], game: Game): void
        + clear_stored_matrix(): void
        + get_data_from_file(): void
        + load_game_from_file(): dict
        + has_stored_data(): bool
        + get_filepath(): str
    }
}

package Store <<Frame>> {
    class StoreFactory {
        # _store(key: srt, file_path: str, value: str): void
        # _get_data_from_store(file_path: str, callback_action: () => void): dict
        # _delete_from_store(key:  str): void
        # _clear_all(file_path: str): void
        # _file_path_exists(file_path: str): boolean
        # _has_data_on_store(file_path: str): boolean
        # _get_store(): dict
    }
}

package Enemy <<Frame>> {
    class EnemyContract {
        + move_piece(game: Game): void
        + get_random_piece_with_legal_moves(board: Board, game: Game): tuple[Piece, (int, int), (int, int)]
    }

    class EasyEnemy {
    }

    class MediumEnemy {
        + get_better_movement_without_adjacent(board: Board, pieces_without_adjacent: List[tuple[int, int]]): tuple[int, int]
        + get_random_piece_with_adjacent(board: Board, game: Game): tuple[Piece, (int, int), (int, int)]
        + should_get_next_hop(game: Game, board: Board, tuple[int, int])
        + manhattan_distance(tuple[int, int], tuple[int, int]): int
        + moves_in_player_piece_direction(game: Game, original_position: tuple[int, int], coords_enemy_moves: List[tuple[int, int]], coords_player_pieces:List[tuple[int, int]]): List[tuple[int, int]]
        + get_random_piece_with_approximation(board: Board, game: Game): tuple[Piece, (int, int), (int, int)]
    }
}
}

EasyEnemy --|> EnemyContract : herda
MediumEnemy --|> EnemyContract : herda

MainMenu -right-|> MenuModel : herda
MainMenu -left-|> MenuContract : herda

Board -right-|> BoardModel : herda
Board -left-|> BoardContract : herda

Game -right-|> GameModel : herda
Game -left-|> GameContract : herda

Graphics -left-|> GraphicsContract : herda
Graphics -right-|> GraphicsModel : herda

Game *--> MainMenu
BoardStore --|> StoreFactory

Board *--> BoardStore

Piece -right-|> PieceModel : herda

Square -right-|> SquareModel : herda

Square "1" o--> "1" Piece : contém

Board "1" *--> "1..*" Square : contém

Graphics "1" o--> "0..*" Board : contém

Game "1" *--> "1" Graphics : contém
Game "1" *-up-> "1" EnemyContract

Game -- Piece

@enduml
